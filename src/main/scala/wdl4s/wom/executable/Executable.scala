package wdl4s.wom.executable

import lenthall.validation.ErrorOr.ErrorOr
import wdl4s.wom.callable.Callable
import wdl4s.wom.graph.{ExecutionInputNode, Graph, GraphNode, GraphNodePort}
import wdl4s.wom.graph.GraphNodePort.WorkflowInputSource

import cats.syntax.validated._

/**
  * Closely related to the WdlNamespace, contains a set of Workflows and Tasks with a single Callable selected as the
  * entry point.
  */
final case class Executable(entryPoint: Callable) extends Graph {

  def graph: Graph = {
    val inputNodes: Map[Callable.InputDefinition, ExecutionInputNode] = entryPoint.inputs.toList.map { i =>
      i -> ExecutionInputNode(i.name, i.womType)
    }.toMap

    val inputLinkings: Map[Callable.InputDefinition, WorkflowInputSource] = inputNodes.map { case (i, n) =>
      i -> n.singleOutputPort
    }

    Graph.fromNodes(inputNodes.values.toSet ++ entryPoint.graph.nodes)
  }

  /**
    * The GraphNodes in this Graph.
    */
  override def nodes: Set[_ <: GraphNode] = graph.nodes

  /**
    * Inputs that must be available before this graph node can be run.
    */
  override def inputPorts: Set[GraphNodePort.InputPort] = Set.empty

  /**
    * Outputs that are generated by this GraphNode
    */
  override def outputPorts: Set[GraphNodePort.OutputPort] = ???

  override def withSuppliedInputs(inputs: Map[String, GraphNodePort.InputPort]): ErrorOr[Graph] = "Can't connect more inputs to an Executable graph".invalidNel
}

object Executable {
  implicit class ExecutableCallable(val c: Callable) extends AnyVal {
    def makeExecutable: ErrorOr[Executable] = ???
  }
}
